from typing import Dict, Optional, List
from datetime import datetime
from app.models.schemas import UserPreference
from app.database.vector_store import VectorStore
from app.config import settings
import logging
import json
import redis.asyncio as redis

logger = logging.getLogger(__name__)

class UserService:
    def __init__(self):
        self.vector_store = VectorStore()
        self.redis_client = redis.from_url(settings.redis_url)
        
    async def get_user_preferences(
        self,
        user_id: str
    ) -> Optional[UserPreference]:
        """Get user preferences"""
        try:
            # Try to get from cache first
            cached_prefs = await self.redis_client.get(f"user:prefs:{user_id}")
            if cached_prefs:
                return UserPreference(**json.loads(cached_prefs))
            
            # If not in cache, get from vector store
            prefs = await self.vector_store.get_user_preferences(user_id)
            if prefs:
                # Cache for future use
                await self.redis_client.set(
                    f"user:prefs:{user_id}",
                    json.dumps(prefs.dict()),
                    ex=settings.cache_ttl
                )
            return prefs
            
        except Exception as e:
            logger.error(f"Error getting user preferences: {str(e)}")
            return None

    async def update_preferences(
        self,
        user_id: str,
        preferences: UserPreference
    ) -> bool:
        """Update user preferences"""
        try:
            # Update in vector store
            success = await self.vector_store.update_user_preferences(
                user_id,
                preferences,
                None  # Embedding will be generated by vector store
            )
            
            if success:
                # Update cache
                await self.redis_client.set(
                    f"user:prefs:{user_id}",
                    json.dumps(preferences.dict()),
                    ex=settings.cache_ttl
                )
            
            return success
            
        except Exception as e:
            logger.error(f"Error updating user preferences: {str(e)}")
            return False

    async def get_user_history(
        self,
        user_id: str,
        limit: int = 10
    ) -> List[Dict]:
        """Get user's interaction history"""
        try:
            history = await self.redis_client.lrange(
                f"user:history:{user_id}",
                0,
                limit - 1
            )
            return [json.loads(h) for h in history]
            
        except Exception as e:
            logger.error(f"Error getting user history: {str(e)}")
            return []

    async def add_to_history(
        self,
        user_id: str,
        interaction: Dict
    ):
        """Add interaction to user's history"""
        try:
            interaction['timestamp'] = datetime.utcnow().isoformat()
            await self.redis_client.lpush(
                f"user:history:{user_id}",
                json.dumps(interaction)
            )
            # Keep only last 100 interactions
            await self.redis_client.ltrim(f"user:history:{user_id}", 0, 99)
            
        except Exception as e:
            logger.error(f"Error adding to user history: {str(e)}")

    async def cleanup(self):
        """Cleanup resources"""
        await self.redis_client.close()